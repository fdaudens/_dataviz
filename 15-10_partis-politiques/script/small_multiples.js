// Generated by CoffeeScript 1.8.0
(function() {
  var SmallMultiples, plotData, setupIsoytpe, transformData;

  SmallMultiples = function() {
    var area, bisect, caption, chart, circle, circle2, color, curYear, data, format, height, line, margin, mousemove, mouseout, mouseover, setupScales, width, xScale, xValue, yAxis, yScale, yValue;
    width = 635;
    height = 30;
    margin = {
      top: 10,
      right: 10,
      bottom: 20,
      left: 35
    };
    data = [];
    circle = null;
    circle2 = null;
    caption = null;
    curYear = null;
    bisect = d3.bisector(function(d) {
      return d.date;
    }).left;
    format = d3.time.format("%Y");
    
    color = d3.scale.ordinal()
      .domain(["Autre","Parti crédit social","Ralliement des créditistes","Alliance réformiste conservatrice canadienne","Conservateur","Parti progressiste-conservateur","Parti réformiste","Parti conservateur du Canada","Bloc québécois","New Democracy","Nouveau Parti démocratique","Parti social démocratique du Canada","Parti libéral du Canada","Parti libéral-travailliste","Parti vert du Canada"])
      .range(["#B6B6B6","#B6B6B6","#B6B6B6","#062F73","#062F73","#062F73","#062F73","#062F73","#00AEEF","#EA8400","#EA8400","#EA8400","#D71920","#D71920", "46AA42"]);
 
    xScale = d3.time.scale().range([0, width]);
    yScale = d3.scale.linear().range([height, 0]);
    xValue = function(d) { return d.date; };
    yValue = function(d) { return d.n; };
    yAxis = d3.svg.axis().scale(yScale).orient("left").ticks(0)
    // .outerTickSize(0)
    .tickSubdivide(1)
    //.tickSize(-width);
    
    // area = d3.svg.area()
    // .x(function(d) { return xScale(d.date); })
    // .y0(height)
    // .y1(function(d) { return yScale(d.value); });

    area = d3.svg.area()
      .x(function(d) { return xScale(xValue(d)); })
      .y0(height)
      .y1(function(d) {  return yScale(yValue(d)); });

    line = d3.svg.line()
    .x(function(d) { return xScale(xValue(d));
    })
    .y(function(d) { return yScale(yValue(d));
    });

    setupScales = function(data) {
      var extentX, maxY;
      maxY = d3.max(data, function(c) { return d3.max(c.values, function(d) { return yValue(d);
      });
      });
      maxY = maxY + (maxY * 1 / 4);
      yScale.domain([0, 215]);  // mon domaine fonctionne

     extentX = ([
d3.min(data, function(c) { return d3.min(c.values, function(d) { return xValue(d);});}),    
d3.max(data, function(c) { return d3.max(c.values, function(d) { return xValue(d);});})
              ]);

     // d3.extent(data[0].values, function(d) {
     //    return xValue(d);
     //  }); -> donne un ajustement relatif à la scale de chaque donnée nestée
      return xScale.domain(extentX);

    };

    chart = function(selection) {
      return selection.each(function(rawData) {
        var div, g, lines, svg;
        data = rawData;
        setupScales(data);
        div = d3.select(this).selectAll(".chart").data(data);
        div.enter().append("div").attr("class", "chart")
          .style("width","100%")
          .append("svg").append("g")
        svg = div.select("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom)
          .attr("viewBox", "0 0 "+(width + margin.left + margin.right)+" "+(height + margin.top + margin.bottom))
          .attr("width","100%")//.attr("height",300)
        g = svg.select("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        g.append("rect").attr("class", "background").style("pointer-events", "all").attr("width", width + margin.right).attr("height", height).on("mouseover", mouseover).on("mousemove", mousemove).on("mouseout", mouseout);
        lines = g.append("g");
        lines.append("path").attr("class", "area").style("pointer-events", "none").style("fill", function(d) { return color(d.key); }).attr("d", function(c) {
          return area(c.values);
        });
        lines.append("path").attr("class", "line").style("pointer-events", "none").attr("d", function(c) {
          return line(c.values);
        });
        lines.append("text").attr("class", "title").attr("text-anchor", "middle").attr("y", height).attr("dy", margin.bottom / 2 + 5).attr("x", width / 2).text(function(c) {
          return c.key;
        });

        // affichage des années sur l'axe X (années fixes)
        lines.append("text").attr("class", "static_year").attr("text-anchor", "start").style("pointer-events", "none").attr("dy", 13).attr("y", height).attr("x", 0).text("1867");

        //   function(c) {
        //   return xValue(c.values[0]).getFullYear();
        // });

        lines.append("text").attr("class", "static_year").attr("text-anchor", "end").style("pointer-events", "none").attr("dy", 13).attr("y", height).attr("x", width).text("2011")

        var counts = {};
        lines.each(function(party){ counts[party.key] = party.values.length; })

        circle2 = lines
            .selectAll('.circle')
            .data(function(c){return c.values})
            .enter()
            .append('circle')
            .filter(function(c) { return counts[c.category] == 1 })
            .attr("class", "circle")
            .attr({ cx: function(c){ return xScale(xValue(c))},
                    cy: function(c){ return yScale(yValue(c))},})
            .attr("r", 5)
           // .attr("opacity", 1)
            .style("pointer-events", "none");

        circle = lines.append("circle").attr("r", 2.2).attr("opacity", 0).style("pointer-events", "none");
        curLegend = lines.append("text").attr("class", "cursorLegend").attr("opacity", 0)

        caption = lines.append("text").attr("class", "caption").attr("text-anchor", "middle").style("pointer-events", "none").attr("dy", -8);
        curYear = lines.append("text").attr("class", "year").attr("text-anchor", "middle").style("pointer-events", "none").attr("dy", 13).attr("y", height);
        return g.append("g").attr("class", "y axis").call(yAxis);
      });
    };
    mouseover = function() {
      circle.attr("opacity", 1.0);
      curLegend.attr("opacity", 1.0);
      d3.selectAll(".static_year").classed("hidden", true);
      return mousemove.call(this);
    };
    mousemove = function() {
      var date, index, year;
      year = xScale.invert(d3.mouse(this)[0]).getFullYear();
      // get nearest year in the "years" set
      var minDist = Infinity; nearestYear = 0;
      for(i in Object.keys(years)) {
        var y = parseInt(Object.keys(years)[i]);
        var dist = Math.abs(y-year);
        if(dist<minDist) { minDist = dist; nearestYear = y; }
      }
      year = nearestYear;
      date = format.parse('' + year);
      index = 0;

      function getYValue(values) {
        for(var i in values) {
          if(values[i].year == year) { return yValue(values[i])}
        }
        return 0;
      }

      circle.attr("cx", xScale(date)).attr("cy", function(c) {
        return yScale(getYValue(c.values));
      });
      curLegend.text(function(c) {
        return getYValue(c.values);
      })
      curLegend.attr("x", xScale(date)).attr("y", function(c) {
        return yScale(getYValue(c.values))-5;
      });

    //  LÀ SE TROUVENT DES ERREURS

    // caption.attr("x", xScale(date)).attr("y", function(c) {
    //     return yScale(yValue(c.values[index]));
    //   }).text(function(c) {
    //     return yValue(c.values[index]);
    //   });
      return curYear.attr("x", xScale(date)).text(year);
    };
    mouseout = function() {
      d3.selectAll(".static_year").classed("hidden", false);
      circle.attr("opacity", 0);
      curLegend.attr("opacity", 0);
      caption.text("");
      return curYear.text("");
    };
    chart.x = function(_) {
      if (!arguments.length) {
        return xValue;
      }
      xValue = _;
      return chart;
    };
    chart.y = function(_) {
      if (!arguments.length) {
        return yValue;
      }
      yValue = _;
      return chart;
    };
    return chart;
  };

  transformData = function(rawData) {

    years = {};
    for(var i in rawData) {
      years[parseInt(rawData[i].year)] = true;
    }
    
    var format, nest;
    format = d3.time.format("%Y");
    rawData.forEach(function(d) {
      d.date = format.parse(d.year);
      return d.n = +d.n;
    });
    nest = d3.nest().key(function(d) {
      return d.category;
    }).sortValues(function(a, b) { return d3.ascending(a.date, b.date);
    }).entries(rawData)
    return nest
  };

  plotData = function(selector, data, plot) {
    return d3.select(selector).datum(data).call(plot);
  };

  setupIsoytpe = function() {
    $("#vis").isotope({
      itemSelector: '.chart',
      layoutMode: 'fitRows',
      getSortData: {
        count: function(e) {
          var d, sum;
          d = d3.select(e).datum();
          sum = d3.sum(d.values, function(d) {
            return d.n;
          });
          return sum * -1;
        },
        name: function(e) {
          var d;
          d = d3.select(e).datum();
          return d.key;
        }
      }
    });
    return $("#vis").isotope({
      sortBy: 'count'
    });
  };

  $(function() {
    var display, plot;
    plot = SmallMultiples();
    display = function(error, rawData) {
      var data;
      if (error) {
        console.log(error);
      }
      data = transformData(rawData);
      plotData("#vis", data, plot);
      return setupIsoytpe();
    };
    queue().defer(d3.csv, "data/data.csv").await(display);
    return d3.select("#button-wrap").selectAll("div").on("click", function() {
      var id;
      id = d3.select(this).attr("id");
      d3.select("#button-wrap").selectAll("div").classed("active", false);
      d3.select("#" + id).classed("active", true);
      return $("#vis").isotope({
        sortBy: id
      });
    });
  });


}).call(this);
